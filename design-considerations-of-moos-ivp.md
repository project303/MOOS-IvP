# Pertimbangan Desain MOOS-IvP

## 1   Pertimbangan Desain MOOS -IvP
Motivasi utama dalam perancangan MOOS-IvP adalah membangun sistem otonom yang sangat mumpuni. Bagian dari gambaran ini mencakup melakukannya dengan biaya jangka pendek dan jangka panjang yang lebih rendah dan jangka waktu yang lebih singkat. Yang kami maksud dengan "perancangan" adalah pilihan dalam arsitektur dan algoritma serta pilihan untuk menyediakan modul-modul utama untuk infrastruktur, otonomi dasar, dan perangkat canggih bagi publik di bawah lisensi Open Source. Perancangan perangkat lunak MOOS-IvP didasarkan pada tiga filosofi arsitektur, (a) paradigma pengemudi di belakang layar, (b) middleware otonomi penerbitan dan langganan, dan (c) otonomi berbasis perilaku. Benang merahnya adalah kemampuan untuk memisahkan pengembangan perangkat lunak untuk keseluruhan sistem menjadi modul-modul berbeda yang dikoordinasikan oleh perangkat lunak infrastruktur yang tersedia untuk domain publik.


### 1.1   Infrastruktur Publik - Kemampuan Berlapis   
Ide arsitektur utama dari MOOS dan IvP adalah pemisahan kemampuan keseluruhan menjadi modul-modul yang terpisah dan berbeda. Kontribusi unik dari MOOS dan IvP adalah metode yang digunakan untuk mengoordinasikan modul-modul tersebut. Ide utama kedua adalah keputusan untuk membuat algoritme dan modul perangkat lunak untuk infrastruktur, otonomi dasar, dan alat-alat canggih tersedia untuk umum di bawah lisensi Open Source. Idenya digambarkan dalam . Ada tiga hal dalam gambar ini - (a) modul yang benar-benar menjalankan suatu fungsi (baji), (b) modul yang mengoordinasikan modul-modul lain (pusat roda), dan (c) penggunaan perangkat lunak pembungkus standar oleh setiap modul untuk memungkinkannya dikoordinasikan (jari-jari).


> **Gambar 1.1: Infrastruktur Publik - Kemampuan Berlapis**\
> Bagian tengah roda mewakili Inti MOOS-IvP. Untuk MOOS, ini berarti MOOSDB dan algoritme pengiriman dan penjadwalan pesan. Untuk IvP, ini berarti manajemen perilaku kemudi IvP dan penyelesai pengoptimalan multi-objektif. Irisan pada roda mewakili modul individual - baik proses MOOS atau perilaku IvP. Jari-jari roda mewakili gagasan bahwa setiap modul mewarisi dari superkelas untuk mengambil kunci fungsionalitas untuk terhubung ke inti. Setiap irisan atau modul berisi pembungkus yang ditentukan oleh superkelas yang melengkapi fungsi modul individual. Irisan yang lebih gelap menunjukkan modul yang tersedia untuk umum dan yang lebih terang adalah modul yang ditambahkan oleh pengguna untuk melengkapi set publik guna mencakup sistem otonomi lapangan tertentu.


Irisan yang lebih gelap dalam mewakili modul aplikasi (bukan infrastruktur) yang menyediakan fungsionalitas dasar dan tersedia untuk umum. Namun, mereka tidak memiliki status khusus yang tidak dapat diubah. Mereka dapat diganti dengan versi yang lebih baik, atau, karena kode sumber tersedia, kode modul yang ada dapat diubah atau ditambah untuk menyediakan versi yang lebih baik atau berbeda (semoga dengan nama yang berbeda - lihat bagian tentang percabangan di bawah). Bagian selanjutnya memberikan ikhtisar sekitar 40 modul tertentu yang saat ini tersedia. Yang kami maksud dengan modul adalah aplikasi MOOS dan perilaku IvP dan komentar di atas berlaku dalam kedua kasus. Irisan kuning dalam mewakili modul atau fungsionalitas yang tidak diimplementasikan yang dapat dibayangkan. Sistem otonomi MOOS-IvP tertentu yang diterjunkan biasanya terdiri dari (a) modul inti MOOS-IvP, (b) beberapa aplikasi MOOS dan perilaku IvP yang tersedia untuk umum, dan (c) aplikasi MOOS dan perilaku IvP tambahan yang mungkin non-publik yang disediakan oleh satu atau lebih pengembang pihak ketiga.

Tujuan dari gagasan infrastruktur publik/kemampuan berlapis adalah untuk mencapai keseimbangan penting - keseimbangan antara penggunaan ulang kode yang efektif dan kebutuhan pengguna untuk menjaga privasi terkait cara mereka memilih untuk menambah basis kode publik dengan modul mereka sendiri untuk mewujudkan sistem otonomi tertentu. Manfaat penggunaan ulang kode merupakan motivasi penting dalam keputusan arsitektur fundamental baik dalam MOOS maupun IvP. Modul yang menyusun basis kode publik MOOS-IvP yang dijelaskan dalam dokumen ini mewakili lebih dari dua puluh tahun kerja upaya pengembangan. Lebih jauh, komponen inti tertentu dari basis kode telah digunakan ratusan bahkan ribuan jam pada selusin atau lebih jenis platform yang digunakan dalam berbagai situasi. Masalah penggunaan ulang kode dibahas selanjutnya.


### 1.2   Penggunaan Kembali Kode   
Penggunaan kembali kode sangat penting, dan dimulai dengan kemampuan untuk memiliki sistem yang terdiri dari modul-modul yang terpisah tetapi terkoordinasi. Kendala teknis utama adalah mencapai pemisahan modul tanpa menimbulkan dampak substansial pada kinerja. Singkatnya, middleware MOOS adalah cara mengoordinasikan proses-proses terpisah yang berjalan pada satu komputer atau melalui beberapa komputer yang terhubung dalam jaringan. IvP adalah cara mengoordinasikan beberapa perilaku otonomi yang berjalan dalam satu proses MOOS.


Faktor-Faktor yang Berkontribusi pada Penggunaan Kembali Kode:

- Bebas dari masalah kepemilikan . Perangkat lunak yang berfungsi sebagai infrastruktur yang digunakan bersama oleh semua komponen (proses MOOS dan perilaku IvP) tersedia di bawah lisensi Open Source. Selain itu, banyak modul MOOS dan IvP yang matang yang menyediakan kapabilitas yang dibutuhkan secara umum juga tersedia untuk umum. Kode yang bersifat kepemilikan atau tidak dirilis untuk umum tentu saja dapat hidup berdampingan dengan kode publik yang tidak bersifat kepemilikan untuk mencakup sistem otonomi yang lebih besar. Sistem seperti itu akan mempertahankan keunggulan strategis atas pesaing jika diinginkan, tetapi memiliki sebagian komponen yang sama dengan pengguna lain.
- Kemandirian modul . Memelihara atau menambah sistem yang terdiri dari sekumpulan modul yang berbeda dapat mulai rusak jika modul tidak mandiri dengan antarmuka yang mudah ditambah. Ketergantungan kompilasi antar modul perlu diminimalkan atau dihilangkan. Pemeliharaan pustaka perangkat lunak inti dan kode aplikasi harus dipisahkan sepenuhnya dari masalah kode tambahan pihak ketiga.
- Antarmuka yang sederhana dan terdokumentasi dengan baik . Upaya yang diperlukan untuk menambahkan modul ke basis kode harus diminimalkan. Dokumentasi diperlukan untuk (a) penggunaan aplikasi dan pustaka yang tersedia untuk umum, dan (b) panduan bagi pengguna dalam menambahkan modul mereka sendiri.
- Kebebasan untuk berinovasi . Infrastruktur tidak memberikan batasan yang tidak semestinya pada cara memecahkan masalah dasar. Infrastruktur tetap netral terhadap teknik dan algoritma yang digunakan dalam modul. Tidak ada modul yang sakral dan modul apa pun dapat diganti.

Manfaat Penggunaan Kembali Kode:

- Keragaman kontributor . Sistem otonomi makin banyak mengandung banyak komponen yang menyentuh banyak bidang keahlian. Hal ini berlaku bahkan untuk penggunaan kendaraan biasa, tetapi menjadi lebih rumit jika mempertimbangkan berbagai sensor dan misi serta cara memanfaatkan sensor dalam mencapai tujuan misi. Sistem yang memungkinkan penggunaan ulang kode secara luas juga merupakan sistem yang memungkinkan kontribusi modul dari sekumpulan pengembang atau pakar yang luas. Hal ini berdampak besar pada masalah yang disebutkan di bawah ini, yaitu biaya yang lebih rendah, kualitas dan keandalan yang lebih tinggi, serta waktu pengembangan yang lebih singkat.
- Biaya lebih rendah . Salah satu manfaat langsung dari penggunaan ulang kode adalah penghindaran dari penemuan ulang modul secara berulang. Suatu kelompok dapat membangun kemampuan secara bertahap dan para ahli bebas untuk berkonsentrasi pada bidang mereka dan hanya mengembangkan modul yang mencerminkan keahlian dan minat mereka. Mungkin yang lebih penting, penggunaan ulang kode memberikan pilihan kepada integrator sistem dalam membangun sistem yang lengkap dari modul-modul individual. Memiliki pilihan mengarah pada peningkatan daya ungkit dalam tawar-menawar untuk persyaratan lisensi yang menguntungkan atau bahkan persyaratan non-eksklusif untuk modul baru. Persyaratan lisensi yang menguntungkan yang diatur di awal dapat menghasilkan biaya jangka panjang yang jauh lebih rendah untuk pemeliharaan kode di masa mendatang atau penambahan perangkat lunak.
- Kemampuan kinerja yang lebih tinggi . Penggunaan kembali kode meningkatkan kemampuan kinerja dalam dua cara. Pertama, karena para ahli bebas menjadi ahli tanpa menciptakan kembali modul di luar keahlian mereka dan disediakan oleh orang lain, pekerjaan mereka sendiri cenderung lebih terfokus dan efisien. Mereka cenderung mencapai kemampuan yang lebih tinggi untuk investasi terbatas yang diberikan dan waktu kinerja yang terbatas. Kedua, karena penggunaan kembali kode memberikan pilihan kepada integrator sistem , ini menciptakan meritokrasi berdasarkan rasio biaya-kinerja optimal dari modul perangkat lunak kandidat. Modul yang kurang mampu dan lebih mahal cenderung tidak mengurangi kemampuan otonomi keseluruhan jika modul alternatif dikembangkan untuk menawarkan pilihan yang kompetitif. Kelangsungan hidup yang terkuat.
- Keandalan kinerja yang lebih tinggi . Bagian penting dari keandalan sistem adalah pengujian. Semakin banyak waktu pengujian dan semakin beragam skenario pengujian, semakin baik. Dan tentu saja semakin banyak waktu yang dihabiskan untuk pengujian pada kendaraan fisik dibandingkan simulasi, semakin baik. Dengan membuat komponen inti dari basis kode publik dan mengizinkan penggunaan kembali oleh komunitas pengguna, komunitas tersebut memberikan kembali layanan yang sangat besar hanya dengan menggunakan perangkat lunak dan mengeluh ketika atau jika terjadi kesalahan. Komponen inti tertentu dari basis kode MOOS-IvP telah memiliki ratusan jika tidak ribuan jam penggunaan pada selusin atau lebih jenis platform dalam berbagai situasi. Dan lebih banyak jam dalam simulasi. Pengujian tidak menggantikan praktik pengkodean yang baik atau metode formal untuk menguji dan memverifikasi kebenaran, tetapi melengkapi kedua aspek tersebut dan ditingkatkan dengan penggunaan kembali kode.
- Waktu pengembangan yang dipersingkat . Penggunaan ulang kode berarti lebih sedikit kode yang dikembangkan ulang yang mengarah pada pengembangan sistem keseluruhan yang lebih cepat. Lebih halus lagi, karena penggunaan ulang kode dapat memberikan pilihan dan persaingan bagi integrator sistem pada modul individual, waktu pengembangan dapat dikurangi sebagai konsekuensinya. Integrator dapat menerima modul yang dikembangkan paling cepat, atau persaingan itu sendiri dapat mempercepat pengembangan. Jika pilihan dan persaingan menghasilkan perjanjian lisensi yang lebih menguntungkan antara integrator dan pengembang, hal ini sendiri dapat memperlancar perjanjian untuk pemeliharaan dan penambahan kode dalam jangka panjang. Terakhir, seperti dibahas di atas, jika penggunaan ulang kode mengarah pada elemen pengujian bug yang digerakkan oleh komunitas, ini juga akan mempercepat laju evolusi menuju sistem otonomi yang matang dan andal.


### 1.3   Filosofi Desain Pengemudi Kursi Belakang   
Ide kunci dalam paradigma pengemudi kursi belakang adalah pemisahan antara kontrol kendaraan dan otonomi kendaraan . Sistem kontrol kendaraan berjalan pada komputer kendaraan utama platform dan sistem otonomi berjalan pada komputer muatan terpisah. Pemisahan ini juga disebut sebagai antarmuka pengontrol misi - pengontrol kendaraan . Manfaat utama adalah pemisahan sistem otonomi platform dari perangkat keras kendaraan yang sebenarnya. Produsen kendaraan menyediakan sistem navigasi dan kontrol yang mampu mengalirkan informasi posisi dan lintasan kendaraan dari komputer kendaraan utama, dan menerima aliran keputusan otonomi seperti arah, kecepatan, dan kedalaman sebagai balasan dari komputer muatan. Bagaimana tepatnya kendaraan menavigasi dan menerapkan kontrol sebagian besar tidak ditentukan pada sistem otonomi yang berjalan dalam muatan. Hubungan tersebut digambarkan dalam .


> **Gambar 1.2: Paradigma pengemudi kursi belakang**\
> Ide utamanya adalah pemisahan otonomi kendaraan dari kontrol kendaraan. Sistem otonomi memberikan perintah arah, kecepatan, dan kedalaman ke sistem kontrol kendaraan. Sistem kontrol kendaraan menjalankan kontrol dan meneruskan informasi navigasi, misalnya, posisi, arah, dan kecepatan, ke sistem otonomi. Paradigma kursi belakang tidak bergantung pada bagaimana sistem otonomi diimplementasikan, tetapi dalam gambar ini arsitektur otonomi MOOS-IvP digambarkan.

Sistem otonomi pada komputer muatan terdiri dari serangkaian proses berbeda yang berkomunikasi melalui basis data terbit-berlangganan yang disebut MOOSDB (Mission Oriented Operating Suite - Database). Salah satu proses tersebut adalah antarmuka ke komputer kendaraan utama, dan proses utama lainnya adalah IvP Helm yang menerapkan sistem otonomi berbasis perilaku. Komunitas MOOS disebut sebagai sistem "otonomi yang lebih besar", atau "sistem otonomi secara keseluruhan" karena MOOS sendiri adalah middleware, dan pengambilan keputusan otonom yang sebenarnya, pemrosesan sensor, manajemen kontak, dll., diimplementasikan sebagai proses MOOS individual.


### 1.4   Filosofi Desain Middleware Publish - Subscribe dan MOOS   
MOOS menyediakan kemampuan middleware berdasarkan arsitektur dan protokol publikasi-berlangganan. Setiap proses berkomunikasi satu sama lain melalui satu proses basis data dalam topologi bintang (). Antarmuka proses tertentu dijelaskan oleh pesan apa yang dihasilkannya (publikasi) dan pesan apa yang dikonsumsinya (langganan). Setiap pesan adalah pasangan variabel-nilai sederhana di mana nilainya biasanya berupa string atau nilai numerik seperti ( STATE , "DEPLOY" ), atau ( NAV_SPEED , 2.2 ). Pesan MOOS juga dapat berisi data biner mentah untuk meneruskan gambar misalnya.


> **Gambar 1.3: Komunitas MOOS**\
> merupakan kumpulan aplikasi MOOS yang biasanya berjalan pada satu mesin dengan ID proses yang terpisah. Setiap proses berkomunikasi melalui satu proses basis data MOOS (MOOSDB) dengan cara publikasi-berlangganan. Setiap proses dapat menjalankan loop internalnya pada frekuensi yang independen satu sama lain dan ditetapkan oleh pengguna. Semua proses dapat dijalankan pada komputer yang sama atau didistribusikan melalui jaringan.

Gagasan utama berkenaan dengan memfasilitasi penggunaan ulang kode adalah bahwa aplikasi sebagian besar bersifat independen, hanya didefinisikan oleh antarmuka mereka, dan aplikasi apa pun dapat dengan mudah diganti dengan versi yang ditingkatkan dengan antarmuka yang cocok. Karena MOOS Core dan banyak aplikasi umum tersedia untuk umum bersama dengan kode sumber di bawah lisensi Open Source GPL, pengguna dapat mengembangkan modul yang ditingkatkan dengan mengubah kode sumber yang ada dan memperkenalkan versi baru dengan nama yang berbeda. Dengan MOOS-IvP 13.2 yang mencakup MOOS V10, pustaka MOOS didistribusikan di bawah lisensi LGPL, untuk memungkinkan pengembangan dan penggunaan aplikasi MOOS komersial di samping aplikasi sumber terbuka. MOOSDB dan aplikasi MOOS tetap berada di bawah lisensi GPL. Istilah MOOS Core mengacu pada (a) aplikasi MOOSDB, dan (b) superkelas Aplikasi MOOS yang diwarisi setiap aplikasi MOOS individu untuk memungkinkan konektivitas ke MOOSDB yang sedang berjalan. Menjaga bagian MOOS Core dari basis kode tetap konstan antara pengembang MOOS memungkinkan sifat aplikasi plug-and-play.


### 1.5   Filosofi Desain Kontrol Berbasis Perilaku dan Helm IvP   
Helm IvP berjalan sebagai aplikasi MOOS tunggal dan menggunakan arsitektur berbasis perilaku untuk mengimplementasikan otonomi. Perilaku adalah modul perangkat lunak berbeda yang dapat dideskripsikan sebagai sistem pakar mini mandiri yang didedikasikan untuk aspek tertentu dari keseluruhan otonomi kendaraan. Implementasi helm dan setiap implementasi perilaku memaparkan antarmuka untuk konfigurasi oleh pengguna untuk serangkaian misi tertentu. Konfigurasi ini sering kali berisi hal-hal khusus seperti serangkaian titik jalan tertentu, area pencarian, kecepatan kendaraan, dan sebagainya. Konfigurasi ini juga berisi spesifikasi ruang status yang menentukan perilaku mana yang aktif dalam situasi apa, dan bagaimana status ditransisikan. Ketika beberapa perilaku aktif dan bersaing untuk mendapatkan pengaruh kendaraan, penyelesai IvP digunakan untuk merekonsiliasi perilaku ().


> **Gambar 1.4: Helm IvP**\
> Helm adalah aplikasi MOOS tunggal yang berjalan sebagai proses pHelmIvP. Ini adalah arsitektur berbasis perilaku di mana keluaran utama perilaku pada setiap iterasi adalah fungsi objektif IvP. Pemecah IvP melakukan optimasi multiobjektif pada rangkaian fungsi untuk menemukan tindakan kendaraan tunggal terbaik, yang kemudian dipublikasikan ke MOOSDB. Fungsi-fungsi tersebut dibangun dan rangkaian tersebut dipecahkan pada setiap iterasi helm - biasanya satu hingga empat kali per detik. Hanya sebagian kecil perilaku yang aktif pada waktu tertentu, tergantung pada situasi kendaraan, dan konfigurasi ruang status yang disediakan oleh pengguna.


Pemecah masalah melakukan koordinasi ini dengan meminta fungsi objektif, yaitu, fungsi utilitas, dari setiap perilaku yang ditetapkan pada ruang keputusan kendaraan, misalnya, kemungkinan pengaturan untuk arah, kecepatan, dan kedalaman. Dalam IvP Helm, fungsi objektif memiliki tipe tertentu - yang ditetapkan secara linier sepotong-sepotong - dan disebut Fungsi IvP. Algoritme pemecah masalah memanfaatkan konstruksi ini untuk menemukan solusi cepat terhadap masalah pengoptimalan yang terdiri dari jumlah tertimbang fungsi yang berkontribusi.

Konsep arsitektur berbasis perilaku sering dikaitkan dengan \cite{?} . Sejak saat itu berbagai solusi untuk masalah pemilihan tindakan, yaitu, masalah koordinasi perilaku yang bersaing, telah diajukan dan diterapkan dalam sistem fisik. Pendekatan yang paling sederhana adalah memprioritaskan perilaku sedemikian rupa sehingga perilaku dengan prioritas tertinggi mengunci semua perilaku lainnya seperti dalam Arsitektur Subsumsi dalam \cite{?} . Pendekatan lain disebut sebagai medan potensial, atau pendekatan penjumlahan vektor (Lihat { \cite{?} }, \cite{?} ) yang menganggap tindakan rata-rata antara beberapa perilaku sebagai kompromi yang wajar. Pendekatan pemilihan-tindakan ini telah digunakan dengan efektivitas yang wajar pada berbagai platform, termasuk robot dalam ruangan, misalnya, \cite{?} , \cite{?} , \cite{?} , \cite{?} , kendaraan darat, misalnya, \cite{?} , dan kendaraan laut, misalnya, \cite{?} , \cite{?} , \cite{?} , \cite{?} , \cite{?} . Namun, pemilihan-tindakan melalui identifikasi perilaku prioritas tertinggi tunggal dan melalui penjumlahan vektor memiliki kekurangan yang diketahui kemudian dijelaskan dalam \cite{?} , \cite{?} dan \cite{?} di mana penulis menganjurkan penggunaan optimasi multi-objektif sebagai metode yang lebih cocok, meskipun lebih mahal secara komputasi, untuk pemilihan tindakan. Model IvP adalah metode untuk mengimplementasikan pemilihan-tindakan berbasis fungsi multi-objektif yang layak secara komputasi dalam implementasi IvP Helm.
